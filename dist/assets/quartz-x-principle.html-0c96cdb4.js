import{_ as t,W as i,X as a,Y as r,Z as d,$ as l,a0 as g,D as n}from"./framework-f64bc974.js";const h={},o=g('<h1 id="定时任务-quartz原理分析" tabindex="-1"><a class="header-anchor" href="#定时任务-quartz原理分析" aria-hidden="true">#</a> 定时任务 - Quartz原理分析</h1><h2 id="_1-quartz概念" tabindex="-1"><a class="header-anchor" href="#_1-quartz概念" aria-hidden="true">#</a> 1. Quartz概念</h2><p>Quartz是一个优秀的任务调度框架， 具有以下特点：</p><ul><li>强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求；</li><li>负载均衡</li><li>高可用</li></ul><h3 id="_1-1-调度器-scheduler" tabindex="-1"><a class="header-anchor" href="#_1-1-调度器-scheduler" aria-hidden="true">#</a> 1.1 调度器：scheduler</h3><p>任务调度的控制器，负责定时任务的调度，并且提供任务和触发器的增删改查等api方法。</p><h3 id="_1-2-任务-job" tabindex="-1"><a class="header-anchor" href="#_1-2-任务-job" aria-hidden="true">#</a> 1.2 任务：job</h3><p>job是实际被调度的任务，每个任务必须指定具体执行任务的实现类，实现类需要继承QuartzJobBean或者实现org.quartz.Job接口，具体的业务逻辑写在execute方法里面。 是否支持并发的注解：@DisallowConcurrentExecution</p><h3 id="_1-3-触发器-trigger" tabindex="-1"><a class="header-anchor" href="#_1-3-触发器-trigger" aria-hidden="true">#</a> 1.3 触发器：trigger</h3><p>trigger用来定义调度时间的概念，即按什么样时间规则去触发任务。主要几种类型：</p><ul><li><strong>SimpleTrigger</strong>：简单触发器，从某个时间开始，每隔多少时间触发，重复多少次。</li><li><strong>CronTrigger</strong>：使用cron表达式定义触发的时间规则，如&quot;0 0 0,2,4 1/1 * ? *&quot; 表示每天的0，2，4点触发。</li><li><strong>DailyTimeIntervalTrigger</strong>：每天中的一个时间段，每N个时间单元触发，时间单元可以是毫秒，秒，分，小时</li><li><strong>CalendarIntervalTrigger</strong>：每N个时间单元触发，时间单元可以是毫秒，秒，分，小时，日，月，年。</li></ul><h4 id="_1-3-1-trigger状态" tabindex="-1"><a class="header-anchor" href="#_1-3-1-trigger状态" aria-hidden="true">#</a> 1.3.1 trigger状态：</h4><ul><li><p>WAITING</p></li><li><p>ACQUIRED，</p></li><li><p>EXECUTING，</p></li><li><p>COMPLETE，</p></li><li><p>BLOCKED，</p></li><li><p>ERROR，</p></li><li><p>PAUSED，</p></li><li><p>PAUSED_BLOCKED，</p></li><li><p>DELETED</p></li></ul><h3 id="_1-4-核心元素关系" tabindex="-1"><a class="header-anchor" href="#_1-4-核心元素关系" aria-hidden="true">#</a> 1.4 核心元素关系</h3><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719211631532.png" alt="image-20220719211631532"><h2 id="_2-scheduler-调度线程" tabindex="-1"><a class="header-anchor" href="#_2-scheduler-调度线程" aria-hidden="true">#</a> 2. Scheduler 调度线程</h2><p>Scheduler 调度线程主要有两个：</p><ul><li><p>执行常规调度的线程</p><p>常规调度线程轮询存储的所有 trigger，如果有需要触发的 trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该 trigger 关联的任务</p></li><li><p>执行 misfired trigger 的线程。</p><p>Misfire 线程是扫描所有的 trigger，查看是否有 misfired trigger，如果有的话根据 misfire 的策略分别处理。</p></li></ul><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719212131722.png" alt="image-20220719212131722"><h3 id="_2-1-quartz-调度线程流程图" tabindex="-1"><a class="header-anchor" href="#_2-1-quartz-调度线程流程图" aria-hidden="true">#</a> 2.1 Quartz 调度线程流程图</h3><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719212254193.png" alt="image-20220719212254193"><h2 id="_3-未正常触发的任务-misfire-job" tabindex="-1"><a class="header-anchor" href="#_3-未正常触发的任务-misfire-job" aria-hidden="true">#</a> 3. 未正常触发的任务：misfire job</h2><p>没有在正常触发时间点触发的任务。主要由以下几种情况导致：</p><ul><li>触发时间在应用不可用的时间内，比如重启</li><li>上次的执行时间过长，超过了下次触发的时间</li><li>任务被暂停一段时间后，重新被调度的时间在下次触发时间之后</li></ul><p>处理misfire job的策略，需要在创建trigger的时候配置，每种trigger对应的枚举值都不同，具体在接口里面有定义。CronTrigger有2种处理misfire的策略：</p><table><thead><tr><th>处理策略</th><th>描述</th></tr></thead><tbody><tr><td>MISFIRE_INSTRUCTION_FIRE_ONCE_NOW</td><td>立即触发一次</td></tr><tr><td>MISFIRE_INSTRUCTION_DO_NOTHING</td><td>忽略，不处理，等待下次触发</td></tr></tbody></table><p>之间的关系：</p><p>scheduler由工厂类SchedulerFactory创建，主要负责job和trigger的持久化管理，包括新增、删除、修改、触发、暂停、恢复调度、停止调度等；</p><p>一个job可以关联多个trigger，但是一个trigger只能关联一个job。</p><h2 id="_4-quzrtz单机模式-原理分析" tabindex="-1"><a class="header-anchor" href="#_4-quzrtz单机模式-原理分析" aria-hidden="true">#</a> 4. Quzrtz单机模式 原理分析</h2><ol><li>scheduler是一个计划调度器容器（总部），容器里面可以盛放众多的JobDetail和trigger，当容器启动后，里面的每个JobDetail都会根据trigger按部就班自动去执行。</li><li>JobDetail是一个可执行的工作，它本身可能是有状态的。</li><li>Trigger代表一个调度参数的配置，什么时候去调。</li><li>当JobDetail和Trigger在scheduler容器上注册后，形成了装配好的作业（JobDetail和Trigger所组成的一对儿），就可以伴随容器启动而调度执行了。</li><li>scheduler是个容器，容器中有一个线程池，用来并行调度执行每个作业，这样可以提高容器效率。</li></ol><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719212814763.png" alt="image-20220719212814763"><h2 id="_5-集群模式" tabindex="-1"><a class="header-anchor" href="#_5-集群模式" aria-hidden="true">#</a> 5. 集群模式</h2><p>Quartz的集群模式指的是<strong>一个集群下多个节点管理同一批任务的调度</strong>，<strong>通过共享数据库的方式实现</strong>，保证同一个任务到达触发时间的时候，<strong>只有一台机器去执行该任务</strong>。<strong>每个节点部署一个单独的quartz实例，相互之间没有直接数据通信。</strong></p><h3 id="_5-1-quartz集群模式部署图" tabindex="-1"><a class="header-anchor" href="#_5-1-quartz集群模式部署图" aria-hidden="true">#</a> 5.1 Quartz集群模式部署图</h3><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719213026199.png" alt="image-20220719213026199" tabindex="0" loading="lazy"><figcaption>image-20220719213026199</figcaption></figure><h3 id="_5-2-集群模式原理分析" tabindex="-1"><a class="header-anchor" href="#_5-2-集群模式原理分析" aria-hidden="true">#</a> 5.2 集群模式原理分析</h3><p>quartz集群是通过数据库表来感知其他的应用的，各个节点之间并没有直接的通信。<strong>只有使用持久的JobStore才能完成Quartz集群</strong>。 数据库表：以前有12张表，现在只有11张表，现在没有存储listener相关的表，多了QRTZ_SIMPROP_TRIGGERS表：</p><table><thead><tr><th>Table name</th><th>Description</th></tr></thead><tbody><tr><td>QRTZ_CALENDARS</td><td>存储Quartz的Calendar信息</td></tr><tr><td>QRTZ_CRON_TRIGGERS</td><td>存储CronTrigger，包括Cron表达式和时区信息</td></tr><tr><td>QRTZ_FIRED_TRIGGERS</td><td>存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td></tr><tr><td>QRTZ_PAUSED_TRIGGER_GRPS</td><td>存储已暂停的Trigger组的信息</td></tr><tr><td>QRTZ_SCHEDULER_STATE</td><td>存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td></tr><tr><td><strong>QRTZ_LOCKS</strong></td><td><strong>存储程序的悲观锁的信息</strong></td></tr><tr><td>QRTZ_JOB_DETAILS</td><td>存储每一个已配置的Job的详细信息</td></tr><tr><td>QRTZ_SIMPLE_TRIGGERS</td><td>存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td></tr><tr><td>QRTZ_BLOG_TRIGGERS</td><td>Trigger作为Blob类型存储</td></tr><tr><td>QRTZ_TRIGGERS</td><td>存储已配置的Trigger的信息</td></tr><tr><td>QRTZ_SIMPROP_TRIGGERS</td><td></td></tr></tbody></table><h4 id="_5-2-1-qrtz-locks行锁表" tabindex="-1"><a class="header-anchor" href="#_5-2-1-qrtz-locks行锁表" aria-hidden="true">#</a> 5.2.1 QRTZ_LOCKS行锁表</h4><p>QRTZ_LOCKS就是Quartz集群实现同步机制的行锁表,包括以下几个锁：</p><ul><li>CALENDAR_ACCESS</li><li>JOB_ACCESS</li><li>MISFIRE_ACCESS</li><li>STATE_ACCESS</li><li>TRIGGER_ACCESS</li></ul><h4 id="_5-2-2-负责任务调度的几个线程" tabindex="-1"><a class="header-anchor" href="#_5-2-2-负责任务调度的几个线程" aria-hidden="true">#</a> 5.2.2 负责任务调度的几个线程</h4><p>负责任务调度的几个线程：</p><ol><li>任务执行线程：通常使用一个线程池(SimpleThreadPool)维护一组线程，负责实际每个job的执行。</li><li>Scheduler调度线程QuartzSchedulerThread ：轮询存储的所有 trigger，如果有需要触发的 trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该 trigger 关联的任务。</li><li>处理misfire job的线程MisfireHandler：轮训所有misfire的trigger，原理就是从数据库中查询所有下次触发时间小于当前时间的trigger，按照每个trigger设定的misfire策略处理这些trigger。</li></ol><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',46),s={href:"https://www.jianshu.com/p/e95d6764b4d9",target:"_blank",rel:"noopener noreferrer"};function c(u,_){const e=n("ExternalLinkIcon");return i(),a("div",null,[o,r("p",null,[r("a",s,[d("Quartz原理分析"),l(e)])])])}const b=t(h,[["render",c],["__file","quartz-x-principle.html.vue"]]);export{b as default};
