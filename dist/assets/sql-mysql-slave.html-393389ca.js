import{_ as n,W as o,X as r,Y as a,Z as i,$ as t,a0 as s,D as l}from"./framework-f64bc974.js";const h={},g=s('<h1 id="mysql-主从复制原理" tabindex="-1"><a class="header-anchor" href="#mysql-主从复制原理" aria-hidden="true">#</a> MySQL - 主从复制原理</h1><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221014225826741.png" alt="image-20221014225826741" style="zoom:50%;"><h2 id="_1-mysql主从同步实现方式" tabindex="-1"><a class="header-anchor" href="#_1-mysql主从同步实现方式" aria-hidden="true">#</a> 1. <strong>MySQL主从同步实现方式</strong></h2><p>MySQL主从同步是基于Bin Log实现的，而Bin Log记录的是原始SQL语句。</p><p><strong>Bin Log</strong>共有三种日志格式，可以<strong>binlog_format</strong>配置参数指定。</p><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>Statement</td><td>记录原始SQL语句，会导致更新时间与原库不一致。 比如 update_time=now()</td></tr><tr><td>Row</td><td>记录每行数据的变化，保证了数据与原库一致，缺点是数据量较大。</td></tr><tr><td>Mixed</td><td>Statement和Row的混合模式，默认采用Statement模式，涉及日期、函数相关的时候采用Row模式，既减少了数据量，又保证了数据一致性。</td></tr></tbody></table><p><strong>常见的主从同步架构有一主多从、双主多从。</strong></p><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221014224519505.png" alt="image-20221014224519505" style="zoom:50%;"><h2 id="_2-mysql主从同步的作用" tabindex="-1"><a class="header-anchor" href="#_2-mysql主从同步的作用" aria-hidden="true">#</a> <strong>2. MySQL主从同步的作用</strong></h2><ol><li>读写分离，提升数据库性能</li><li>容灾恢复，主服务器不可用时，从服务器提供服务，提高可用性</li><li>冗余备份，主服务器数据损坏丢失，从服务器保留备份</li></ol><h3 id="_2-1-一主多从架构" tabindex="-1"><a class="header-anchor" href="#_2-1-一主多从架构" aria-hidden="true">#</a> 2.1 <strong>一主多从架构：</strong></h3><p>一般是主库负责所有读写请求，而从库只负责容灾恢复和冗余备份。</p><p>如果做了读写分离的话，主库负责写请求，从库负责读请求，可以提升数据库性能。</p><h3 id="_2-2-双主多从架构" tabindex="-1"><a class="header-anchor" href="#_2-2-双主多从架构" aria-hidden="true">#</a> 2.2 <strong>双主多从架构：</strong></h3><p>一般是主库1负责所有读写请求，主库2不对外提供服务，只用来容灾恢复。</p><p>相比一主多从架构，双主多从架构可以减少宕机时间，更快恢复数据库可用状态。</p><h2 id="_3-主动同步的原理" tabindex="-1"><a class="header-anchor" href="#_3-主动同步的原理" aria-hidden="true">#</a> <strong>3. 主动同步的原理</strong></h2><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221014224754176.png" alt="image-20221014224754176" style="zoom:80%;"><ol><li>当主库数据发生变更时，写入本地Bin Log文件</li><li>从库IO线程发起dump主库Bin Log文件的请求</li><li>主库IO线程推送Bin Log文件到从库中</li><li>从库IO线程把Bin Log内容写入本地的Relay Log文件中</li><li>从库SQL线程读取Relay Log文件内容</li><li>从库SQL线程重新执行一遍SQL语句</li></ol><h2 id="_4-主从同步延迟问题" tabindex="-1"><a class="header-anchor" href="#_4-主从同步延迟问题" aria-hidden="true">#</a> <strong>4. 主从同步延迟问题</strong></h2><p>主从同步最常遇到的问题就是主从同步延迟，可以通过在从库上执行<strong>show slave status</strong>命令查看延迟时间，<strong>Seconds_Behind_Master</strong>表示延迟的秒数。</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221014225151555.png" alt="image-20221014225151555" tabindex="0" loading="lazy"><figcaption>image-20221014225151555</figcaption></figure><h3 id="_4-1-主从同步延迟的原因有哪些" tabindex="-1"><a class="header-anchor" href="#_4-1-主从同步延迟的原因有哪些" aria-hidden="true">#</a> <strong>4.1 主从同步延迟的原因有哪些？</strong></h3><ol><li>从库机器性能较差 主库负责所有读写请求，从库只用来备份，会用性能较差的机器，执行时间自然较慢。</li><li>从库压力更大 读写分离后，主库负责写请求，从库负责读请求。 互联网应用一般读请求更多，所以从库读压力更大，占用更多CPU资源。</li><li>网络延迟 当主库的Bin Log文件往从库上发送时，可能产生网络延迟，也会导致从库数据跟不上。</li><li>主库有大事务 当主库上有个大事务需要执行5分钟，把Bin Log文件发送到从库，从库至少也需要执行5分钟，所以这时候从库就出现了5分钟的延迟。</li></ol><h3 id="_4-2-主从同步延迟的解决方案" tabindex="-1"><a class="header-anchor" href="#_4-2-主从同步延迟的解决方案" aria-hidden="true">#</a> 4.2 <strong>主从同步延迟的解决方案？</strong></h3><ol><li>从库机器性能较差 把从库换成跟主库同等规格的机器。</li><li>从库压力更大 多搞几台从库，分担读请求压力。</li><li>网络延迟 联系运维或者云服务提供商解决。</li><li>主库有大事务 把大事务分割成小事务执行，大事务不但会产生从库延迟，还可能产生死锁，降低数据库并发性能，所以尽量少用大事务。</li></ol><h2 id="_5-如何提升主从同步性能" tabindex="-1"><a class="header-anchor" href="#_5-如何提升主从同步性能" aria-hidden="true">#</a> <strong>5. 如何提升主从同步性能</strong></h2><h3 id="_5-1-从库开启多线程复制" tabindex="-1"><a class="header-anchor" href="#_5-1-从库开启多线程复制" aria-hidden="true">#</a> 5.1. 从库开启多线程复制</h3><p>就是在主从同步的最后两步使用多线程，修改配置 <strong>slave_parallel_workers</strong>=4，代表开启4个复制线程。</p><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221014225527025.png" alt="image-20221014225527025" style="zoom:50%;"><h3 id="_5-2-修改同步模式-改为异步" tabindex="-1"><a class="header-anchor" href="#_5-2-修改同步模式-改为异步" aria-hidden="true">#</a> 5.2 修改同步模式，改为异步</h3><p><strong>主从同步共有三种复制方式：</strong></p><ol><li>全同步复制 当主库执行完一个事务，并且所有从库都执行完该事务后，才给客户端返回成功。</li><li>半同步复制 至少有一个从库执行完成后，就给客户端返回成功。</li><li>异步复制 主库执行完后，立即返回成功，不关心从库是否执行完成。</li></ol><p>如果对数据安全性要求没那么高，可以把同步模式改成半同步复制或者异步复制。</p><h3 id="_5-3-修改从库bin-log配置" tabindex="-1"><a class="header-anchor" href="#_5-3-修改从库bin-log配置" aria-hidden="true">#</a> 5.3 修改从库Bin Log配置</h3><p><strong>修改sync_binlog配置：</strong></p><blockquote><p>sync_binlog=0 ，表示写binlog不立即刷新磁盘，由系统决定什么时候刷新磁盘。 sync_binlog=1，每次写binlog都刷新磁盘，安全性高，性能差。 sync_binlog=N，写N次binlog才刷新磁盘。</p></blockquote><p>从库对数据安全性要求没那么高，可以设置sync_binlog=0。</p><p><strong>修改innodb_flush_log_at_trx_commit配置：</strong></p><blockquote><p>innodb_flush_log_at_trx_commit=0，每隔一秒钟，把事务日志刷新到磁盘。 innodb_flush_log_at_trx_commit=1，每次事务都刷新到磁盘。 innodb_flush_log_at_trx_commit=2，每次事务都不主动刷新磁盘，由系统决定什么时候刷新磁盘。</p></blockquote><p>从库对数据安全性要求没那么高，可以设置innodb_flush_log_at_trx_commit=2。</p><h2 id="_6-知识点总结" tabindex="-1"><a class="header-anchor" href="#_6-知识点总结" aria-hidden="true">#</a> 6. <strong>知识点总结：</strong></h2><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221014225826741.png" alt="image-20221014225826741" tabindex="0" loading="lazy"><figcaption>image-20221014225826741</figcaption></figure><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',44),d={href:"https://zhuanlan.zhihu.com/p/533187002",target:"_blank",rel:"noopener noreferrer"},c={href:"https://pdai.tech/md/db/sql-mysql/sql-mysql-slave.html",target:"_blank",rel:"noopener noreferrer"};function _(p,m){const e=l("ExternalLinkIcon");return o(),r("div",null,[g,a("p",null,[a("a",d,[i("高级程序员必知必会，一文详解MySQL主从同步原理"),t(e)])]),a("p",null,[a("a",c,[i("MySQL - 主从复制与读写分离"),t(e)])])])}const u=n(h,[["render",_],["__file","sql-mysql-slave.html.vue"]]);export{u as default};
