import{_ as a,W as e,X as t,Y as n,Z as p,$ as o,a0 as c,D as l}from"./framework-f64bc974.js";const i={},r=c(`<h1 id="类加载器-常见面试" tabindex="-1"><a class="header-anchor" href="#类加载器-常见面试" aria-hidden="true">#</a> 类加载器（常见面试）</h1><h2 id="面试官-请说说你理解的类加载器。" tabindex="-1"><a class="header-anchor" href="#面试官-请说说你理解的类加载器。" aria-hidden="true">#</a> <strong>面试官：请说说你理解的类加载器。</strong></h2><hr><p>我：通过一个类的<strong>全限定名来获取描述此类的二进制字节流</strong>这个动作放到<strong>Java虚拟机外部去实现</strong>，以便让应用程序<strong>自己决定</strong>如何去获取所需要的类。实现这个动作的代码模块称为**“类加载器”**。</p><h2 id="面试官-说说有哪几种类加载器-他们的职责分别是什么-他们之前存在什么样的约定。" tabindex="-1"><a class="header-anchor" href="#面试官-说说有哪几种类加载器-他们的职责分别是什么-他们之前存在什么样的约定。" aria-hidden="true">#</a> <strong>面试官：说说有哪几种类加载器，他们的职责分别是什么，他们之前存在什么样的约定。</strong></h2><hr><p>我：emmmm，我在纸上边画边讲吧。</p><p>类加载的结构如下：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/img/image-20190929221807667.png" alt="image-20190929221807667" tabindex="0" loading="lazy"><figcaption>image-20190929221807667</figcaption></figure><p><strong>BootstrapClassLoader</strong>：启动类类加载器，它用来加载&lt;JAVA_HOME&gt;/jre/lib路径,**-**Xbootclasspath参数指定的路径以&lt;JAVA_HOME&gt;/jre/classes中的类。BootStrapClassLoader是由c++实现的。</p><p><strong>ExtClassLoader</strong>：拓展类类加载器，它用来加载&lt;JAVA_HOME&gt;/jre/lib/ext路径以及java.ext.dirs系统变量指定的类路径下的类。</p><p><strong>AppClassLoader</strong>：应用程序类类加载器，它主要加载应用程序ClassPath下的类（包含jar包中的类）。它是java应用程序默认的类加载器。</p><p><strong>用户自定义类加载器</strong>：用户根据自定义需求，自由的定制加载的逻辑，继承ClassLoader，仅仅覆盖findClass（）即将继续遵守双亲委派模型。</p><p>在虚拟机启动的时候会初始化BootstrapClassLoader，然后在Launcher类中去加载ExtClassLoader、AppClassLoader，并将AppClassLoader的parent设置为ExtClassLoader，并设置线程上下文类加载器。</p><p><strong>Launcher</strong>是JRE中用于启动程序入口main()的类，让我们看下Launcher的代码</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>
public Launcher() {
        Launcher.ExtClassLoader var1;
        try {
            //加载扩展类类加载器
            var1 = Launcher.ExtClassLoader.getExtClassLoader();
        } catch (IOException var10) {
            throw new InternalError(&quot;Could not create extension class loader&quot;, var10);
        }

        try {
            //加载应用程序类加载器，并设置parent为extClassLoader
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError(&quot;Could not create application class loader&quot;, var9);
        }
        //设置默认的线程上下文类加载器为AppClassLoader
        Thread.currentThread().setContextClassLoader(this.loader);
        //此处删除无关代码。。。
        }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面画的几种类加载器是遵循<strong>双亲委派模型</strong>的，其实就是，当一个类加载器去加载类时先尝试让父类加载器去加载，如果父类加载器加载不了再尝试自身加载。这也是我们在自定义ClassLoader时java官方建议遵守的约定。</p><h2 id="面试官插嘴-extclassloader为什么没有设置parent" tabindex="-1"><a class="header-anchor" href="#面试官插嘴-extclassloader为什么没有设置parent" aria-hidden="true">#</a> **面试官插嘴：**ExtClassLoader为什么没有设置parent？</h2><p>让我们看看下面代码的输出结果</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看看结果是啥</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Launcher</span>$<span class="token class-name">AppClassLoader</span><span class="token annotation punctuation">@18b4aac2</span>
<span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Launcher</span>$<span class="token class-name">ExtClassLoader</span><span class="token annotation punctuation">@5a61f5df</span>
<span class="token keyword">null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为BootstrapClassLoader是由c++实现的，所以并不存在一个Java的类，因此会打印出null，所以在ClassLoader中，null就代表了BootStrapClassLoader（有些片面）。</p><h3 id="双亲委派模型的好处" tabindex="-1"><a class="header-anchor" href="#双亲委派模型的好处" aria-hidden="true">#</a> 双亲委派模型的好处</h3><p>双亲委派模型能<strong>保证基础类仅加载一次</strong>，不会让jvm中存在重名的类。比如String.class，每次加载都委托给父加载器，最终都是BootstrapClassLoader，都保证java核心类都是BootstrapClassLoader加载的，保证了java的安全与稳定性。</p><p>API不会被篡改</p><h2 id="面试官-那自己怎么去实现一个classloader呢-请举个实际的例子。" tabindex="-1"><a class="header-anchor" href="#面试官-那自己怎么去实现一个classloader呢-请举个实际的例子。" aria-hidden="true">#</a> <strong>面试官：那自己怎么去实现一个ClassLoader呢？请举个实际的例子。</strong></h2><hr><p>我：好的（脸上笑嘻嘻，心里mmp）。</p><p>自己实现ClassLoader时只需要继承ClassLoader类，然后覆盖findClass（String name）方法即可完成一个带有双亲委派模型的类加载器。</p><p>我们看下ClassLoader#loadClass的代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 查看是否已经加载过该类，加载过的类会有缓存，是使用native方法实现的</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">//父类不为空则先让父类加载</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">//父类是null就是BootstrapClassLoader，使用启动类类加载器加载</span>
                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 父类类加载器不能加载该类</span>
                <span class="token punctuation">}</span>

                <span class="token comment">//如果父类未加载该类</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// If still not found, then invoke findClass in order</span>
                    <span class="token comment">// to find the class.</span>
                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">//让当前类加载器加载</span>
                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> c<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经典的模板方法模式，子类只需要实现findClass，关心从哪里加载即可。</p><p>还有一点，parent需要自己设置哦，可以放在构造函数做这个事情。</p><h2 id="面试官插嘴-为什么不继承appclassloader呢" tabindex="-1"><a class="header-anchor" href="#面试官插嘴-为什么不继承appclassloader呢" aria-hidden="true">#</a> **面试官插嘴：**为什么不继承AppClassLoader呢？</h2><p>我：因为它和ExtClassLoader都是Launcher的静态类，都是包访问路径权限的。</p><h3 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h3>`,37),u={href:"https://zhuanlan.zhihu.com/p/54693308",target:"_blank",rel:"noopener noreferrer"},d=n("em",null,"类加载器",-1);function k(v,m){const s=l("ExternalLinkIcon");return e(),t("div",null,[r,n("p",null,[n("a",u,[p("好怕怕的"),d,o(s)])])])}const b=a(i,[["render",k],["__file","java-jvm-classload-interview.html.vue"]]);export{b as default};
