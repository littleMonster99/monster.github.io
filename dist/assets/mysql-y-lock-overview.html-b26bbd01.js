import{_ as e,W as a,X as i,a0 as l}from"./framework-f64bc974.js";const r={},p=l('<h1 id="锁机制" tabindex="-1"><a class="header-anchor" href="#锁机制" aria-hidden="true">#</a> 锁机制</h1><h2 id="_1-锁维度" tabindex="-1"><a class="header-anchor" href="#_1-锁维度" aria-hidden="true">#</a> 1. 锁维度</h2><p>锁有好几种维度</p><h3 id="_1-1-类型维度" tabindex="-1"><a class="header-anchor" href="#_1-1-类型维度" aria-hidden="true">#</a> 1.1 类型维度</h3><ul><li><p>共享锁（读锁/S锁）</p></li><li><p>排他锁（写锁/X 锁）</p><p>类型细分</p><ul><li>意向共享锁</li><li>意向排他（互斥）锁</li></ul></li><li><p>悲观锁（使用锁，既for update）</p></li><li><p>乐观锁（使用版本号字段，类似 CAS 机制，既用户自己控制。缺点：并发很高的时候，多了很多无用的重试）</p></li></ul><h3 id="_1-2-锁的粒度-粒度维度" tabindex="-1"><a class="header-anchor" href="#_1-2-锁的粒度-粒度维度" aria-hidden="true">#</a> 1.2 锁的粒度（粒度维度）</h3><ul><li><p>表锁</p></li><li><p>页锁（Mysql BerkeleyDB 引擎）</p></li><li><p>行锁（InnoDB）</p><p>行锁的实现原理就是锁住聚集索引，如果你查询的时候，没有正确地击中索引，MySql 优化器将会抛弃行锁，使用表锁。</p></li></ul><h3 id="_1-3-锁的算法-算法维度" tabindex="-1"><a class="header-anchor" href="#_1-3-锁的算法-算法维度" aria-hidden="true">#</a> 1.3 锁的算法（算法维度）</h3><ul><li>Record Lock（单行记录）</li><li>Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）</li><li>Next-key Lock（Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身。MySQL 防止幻读，就是使用此锁实现）</li></ul><h2 id="_2-默认的读操作-上锁吗" tabindex="-1"><a class="header-anchor" href="#_2-默认的读操作-上锁吗" aria-hidden="true">#</a> 2. 默认的读操作，上锁吗？</h2><p>默认是MVCC机制（“一致性非锁定读”）保证RR 级别的隔离正确性。是不上锁的</p><p>可以选择手动上锁</p><ul><li><p>排他锁：select xxxx for update</p></li><li><p>共享锁：select xxx lock in share mode</p><p>称为一致性锁定读</p></li></ul><p>使用锁之后，就能在RR 级别下，避免幻读。当然默认的MVCC读，也能避免幻读</p><h2 id="_3-mysql-的-serializable-有啥用呢" tabindex="-1"><a class="header-anchor" href="#_3-mysql-的-serializable-有啥用呢" aria-hidden="true">#</a> 3 MySQL 的 SERIALIZABLE 有啥用呢？</h2><p>MySQL RR能够防止幻读,那么，SERIALIZABLE 有啥用呢？</p><p>他可以<strong>防止丢失更新</strong></p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/img/image-20190912235538188.png" alt="image-20190912235538188" tabindex="0" loading="lazy"><figcaption>image-20190912235538188</figcaption></figure><p>这个时候，我们必须使用SERIALIZABLE 级别进行串行读取。</p>',19),d=[p];function h(c,s){return a(),i("div",null,d)}const n=e(r,[["render",h],["__file","mysql-y-lock-overview.html.vue"]]);export{n as default};
