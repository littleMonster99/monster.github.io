import{_ as e,W as a,X as i,a0 as s}from"./framework-f64bc974.js";const r={},t=s('<h1 id="redis缓存雪崩" tabindex="-1"><a class="header-anchor" href="#redis缓存雪崩" aria-hidden="true">#</a> Redis缓存雪崩</h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介" aria-hidden="true">#</a> 1. 简介</h2><p>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成<strong>数据库短时间内承受大量请求而崩掉</strong></p><h2 id="_2-解决办法" tabindex="-1"><a class="header-anchor" href="#_2-解决办法" aria-hidden="true">#</a> 2. 解决办法</h2><ul><li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略</li><li>事中：本地chcache缓存 + hystrix限流&amp;降级，避免Mysql崩掉</li><li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li></ul><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/img/image-20191008225446152.png" alt="image-20191008225446152" tabindex="0" loading="lazy"><figcaption>image-20191008225446152</figcaption></figure>',6),n=[t];function c(d,h){return a(),i("div",null,n)}const o=e(r,[["render",c],["__file","redis-x-question-ache-valanche.html.vue"]]);export{o as default};
