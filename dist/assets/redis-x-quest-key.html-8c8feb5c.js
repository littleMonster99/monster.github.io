import{_ as e,W as a,X as r,a0 as d}from"./framework-f64bc974.js";const i={},s=d('<h1 id="如何解决-redis-的并发竞争-key-问题" tabindex="-1"><a class="header-anchor" href="#如何解决-redis-的并发竞争-key-问题" aria-hidden="true">#</a> 如何解决 Redis 的并发竞争 Key 问题</h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介" aria-hidden="true">#</a> 1. 简介</h2><p>所谓 redis 的并发竞争 key 的问题也就是多个系统同时对一个key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同</p><h2 id="_2-解决方案" tabindex="-1"><a class="header-anchor" href="#_2-解决方案" aria-hidden="true">#</a> 2.解决方案</h2><h2 id="_2-1-分布式锁" tabindex="-1"><a class="header-anchor" href="#_2-1-分布式锁" aria-hidden="true">#</a> 2.1 分布式锁</h2><p>分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><blockquote><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p></blockquote>',7),t=[s];function o(h,c){return a(),r("div",null,t)}const _=e(i,[["render",o],["__file","redis-x-quest-key.html.vue"]]);export{_ as default};
