import{_ as e,W as a,X as i,a0 as l}from"./framework-f64bc974.js";const n={},r=l(`<h1 id="联合索引" tabindex="-1"><a class="header-anchor" href="#联合索引" aria-hidden="true">#</a> 联合索引</h1><h2 id="_1-什么是联合索引" tabindex="-1"><a class="header-anchor" href="#_1-什么是联合索引" aria-hidden="true">#</a> 1. 什么是联合索引</h2><p>两个或更多个列上的索引被称为联合索引，联合索引又叫复合索引。</p><p>对于联合索引：</p><ul><li>MySql从左到右使用索引中字段</li><li>一个查询可以只使用索引中的一部分，但只能是最左部分（最左前缀）</li></ul><p>例如：</p><p>索引是key index（a,b,c） 可以支持<strong>a|a,b|a,b,c</strong>，三种组合查找，但不支持b,c 进行查找。当最左侧字段是常量引用时，索引就十分有效</p><h2 id="_2-需要遵循的规则" tabindex="-1"><a class="header-anchor" href="#_2-需要遵循的规则" aria-hidden="true">#</a> 2. 需要遵循的规则</h2><ol><li>需要加索引的字段，要在where条件中</li><li>数据量少的字段不需要加索引</li><li>如何where条件中是or关系，加索引不起作用</li><li>符合最左前缀原则</li></ol><h2 id="_3-原理" tabindex="-1"><a class="header-anchor" href="#_3-原理" aria-hidden="true">#</a> 3. 原理</h2><h3 id="_3-1-b-tree结构" tabindex="-1"><a class="header-anchor" href="#_3-1-b-tree结构" aria-hidden="true">#</a> 3.1 B+Tree结构</h3><p>每一个磁盘快在mysql中是一个页，页大小是固定的，mysql innodb的默认的页大小是16k。每个索引会分配在页上的数量是由字段的大小决定。当字段值长度越长，每一页上的数量就会越少，因此在一定数据量的情况下，所以的深度会越深，影响索引查找效率</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/img/image-20190909223519018.png" alt="image-20190909223519018" tabindex="0" loading="lazy"><figcaption>image-20190909223519018</figcaption></figure><p>对于复合索引（多列b+tree,使用多列值组合而成的b+tree索引）。遵循最左前缀原则，从左到右的使用索引中的字段，<strong>一个查询可以只使用索引中的一部分，但只能是做左侧部分</strong></p><h3 id="_3-2-实例" tabindex="-1"><a class="header-anchor" href="#_3-2-实例" aria-hidden="true">#</a> 3.2 实例</h3><p>创建表test</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>create table test(

a int,

b int,

c int,

KEY a(a,b,c)

);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如（a,b,c）的时候，b+tree是按照从<strong>左到右的顺序来建立搜索树</strong>的</p><ul><li>当（a =? and b= ? and c=?) 这样的数据来检索的时候 <ul><li>b+树会优先比较a列来确定下一步的方向</li><li>如果a列相同再依次比较b列和c列</li><li>最后得到检索数据</li></ul></li><li>但当（b=? and c =?）这样没有a列的数据来的时候 <ul><li>b+树就不知道下一步该查那个节点，因为建立搜索树的时候a列就是第一个比较因子。必须要先跟a列来搜索才能知道下一步去哪里查询</li></ul></li><li>当（a=? and c =?）这样的数据来检索时 <ul><li>b+树可以用a列来制定搜索方向，但下一个字段b列的缺失，只能吧a列的数据找到</li><li>然后在匹配c列的数据</li></ul></li></ul><h2 id="_4-多列索引的应用" tabindex="-1"><a class="header-anchor" href="#_4-多列索引的应用" aria-hidden="true">#</a> 4. 多列索引的应用</h2><h3 id="_4-1-多列索引在and查询中的应用" tabindex="-1"><a class="header-anchor" href="#_4-1-多列索引在and查询中的应用" aria-hidden="true">#</a> 4.1 多列索引在and查询中的应用</h3><ul><li><p>select * from test where a=? and b=? and c=?；</p><p>查询效率最高，索引全覆盖。</p></li><li><p>select * from test where a=? and b=?</p><p>索引覆盖a和b。</p></li><li><p>select * from test where b=? and a=?</p><p>经过mysql的查<strong>询分析器的优化，索引覆盖a和b</strong>。</p></li><li><p>select * from test where a=?；</p><p>索引覆盖a。</p></li><li><p>select * from test where b=? and c=?</p><p>没有a列，不走索引，索引失效。</p></li><li><p>select * from test where c=?；</p><p>没有a列，不走索引，索引失效。</p></li></ul><h3 id="_4-2-多列索引在范围查询中应用" tabindex="-1"><a class="header-anchor" href="#_4-2-多列索引在范围查询中应用" aria-hidden="true">#</a> 4.2 多列索引在范围查询中应用</h3><ul><li><p>select * from test where a=? and b between ? and ? and c=?；</p><p>索引覆盖a和b，<strong>因b列是范围查询，因此c列不能走索引</strong>。</p></li><li><p>select * from test where a between ? and ? and b=?；</p><p>a列走索引，因a列是范围查询，因此b列是无法使用索引。</p></li><li><p>select * from test where a between ? and ? and b between ? and ? and c=?；</p><p>a列走索引，因a列是范围查询，b列是范围查询也不能使用索引。</p></li></ul><h3 id="_4-3-多列索引在排序中应用" tabindex="-1"><a class="header-anchor" href="#_4-3-多列索引在排序中应用" aria-hidden="true">#</a> 4.3 <strong>多列索引在排序中应用</strong></h3><ul><li><p>select * from test where a=? and b=? order by c；</p><p>a、b、c三列全覆盖索引，查询效率最高。</p></li><li><p>select * from test where a=? and b between ? and ? order by c；</p><p>a、b列使用索引查找，因b列是范围查询，因此c列不能使用索引，会出现file sort。</p></li></ul><h2 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结" aria-hidden="true">#</a> 5. 总结</h2><ul><li><p>联合索引的使用在写where调的顺序无关，mysql 查询分析会进行优化而使用索引，但是为了减轻查询分析器的压力，最好和索引的从左到右的顺序一致</p></li><li><p>使用等值查询，多列同时查询，索引会一直传递并生效。因此等值查询效率最好。</p></li><li><p>索引查找遵循最左侧原则。<strong>但是遇到范围查询列之后的列索引失效。</strong></p></li><li><p>排序也能使用索引，合理使用索引排序，避免出现file sort。</p></li></ul>`,28),d=[r];function t(s,c){return a(),i("div",null,d)}const p=e(n,[["render",t],["__file","mysql-c-index-uni.html.vue"]]);export{p as default};
